# 냄새1 이해하기 힘든 이름

- 깔끔한 코드에서 가장 중요한 것 중 하나가 바로 '좋은 이름' 이름이다.
- 함수, 변수, 클래스, 모듈의 이름 등 모두 어떤 역할을 하는지 어떻게 쓰이는지 직관적이어야 한다.

- 사용할 수 있는 리팩토링 기술
    - 함수 선언 변경하기(Change Function Declaration)
    - 변수 이름 바꾸기(Rename Variable)
    - 필드 이름 바꾸기(Rename Field)

## 리팩토링 1. 함수 선언 변경하기

Change Function Declaration

- 좋은 이름을 가진 함수는 함수가 어떻게 구현되었는지 코드를 보지 않아도 이름만 보고도 이해할 수 있다. 

- 좋은 이름을 찾아내느 방법? (함수에 주석을 작성한 다음, 주석을 함수이름으로 만들어 본다)

- 함수의 매개변수
    - 함수 내부의 문맥을 결정한다.(전화번호 포매팅 함수)
    - 의존성을 결정한다. (Payment 만기일 계산함수)


## 리팩토링 2. 변수 이름 바꾸기
Rename Variable

- 더 많이 사용되는 변수일수록 그 이름이 더 중요하다.
    - 람다식에서 사용하는 변수 vs 함수의 매개변수

- 다이나믹 타입을 지원하는 언어에서는 타입을 이름에 넣기도 한다. 
- 여러 함수에 걸쳐 쓰이는 필드 이름에는 더 많이 고민하고 이름을 짓는다.


## 리팩토링 3. 필드 이름 바꾸기
Rename Field

- Recode 자료 구조의 필드 이름은 프로그램 전반에 걸쳐 참조도리 수 있기 때문에 매우 중요하다.

- Record 자료 구조: 특정 데이터와 관련있는 필드를 묶어놓은 자료구조
- 파이썬의 Dictionary,또는 줄여서 dicts.
- c#의 Record
- 자바 14버전부터 지원
- 자바에서는 Getter와 Setter메소드 이름도 필드의 이름과 비슷하게 간주할 수 있다.



# 냄새2 중복 코드

Duplicated Code

- 중복 코드의 단점
    - 비슷한지, 완전히 동일한 코드인지 주의깊게 봐야한다.
    - 코드를 변경할 때, 동일한 모든 곳의 코드를 변경해야 한다.
- 사용할 수 있는 리팩토링 기술
    - 동일한 코드를 여러 메소드에서 사용하는 경우, 함수 추출하기(Extract Function)
    - 코드가 비슷하게 생겼지만 완전히 같지는 않은 경우, 코드 분리하기(Slide Statements)
    - 여러 하위 클래스에 동일한 코드가 있다면, 메소드 올리기(Pull Up Method)


## 리팩토링4 함수 추출하기
Extract Function

- 의도와 구현 분리하기
- 무슨 일을 하는 코드인지 알아내려고 노력해야 하는 코드라면 해당 코드를 함수로 분리하고 함수 이름으로 '무슨 일을 하는지' 표현할 수 있다.

- 한줄 짜리 메소드도 괜찮은가?
    - 한줄짜리 메소드의 스택까지 신경 안써도 된다.
- 거대한 함수 안에 들어있는 주석은 추출한 함수를 찾는데 있어서 좋은 단서가 될 수 있다.


## 리팩토링5. 코드 정리하기
Slide Statements

- 관련있는 코드끼리 묶여있어야 코드를 더 쉽게 이해할 수 있다.
- 함수에서 사용할 변수를 상단에 미리 정의하기 보다는, 해당 변수를 사용하는 코드 바로 위에 선언하자.

- 관련 있는 코드끼리 묶은 다음, 함수 추출하기(Extract Function)를 사용해서 더 깔끔하게 분리할 수도 있다. 

## 리팩토링6 메소드 올리기
Pull Up Method

- 중복 코드는 당장은 잘 동작하더라도 미래에 버그를 만들어 낼 빌미를 제공한다.
    - A에서 코드를 고치고, B에는 반영하지 않은 경우
- 여러 하위 클래스에 동일한 코드가 있다면, 손쉽게 이 방법을 적용할 수 있다.
- 비슷하지만 이름 값만 다른 경우라면, '함수 매개변수화하기 (Parameterize Function)' 리팩토링을 적용한 이후에ㅡ 이 방법을 사용할 수 있다.

- 하위 클래스에 있는 코드가 상위 클래스가 아닌 하위 클래스 기능에 의존하고 있다면, '필드 올리기'를 적용한 이후에 이 방법을 적용할 수 있다.

- 두 메소드가 비슷한 절차를 따르고 있다면 템플릿 메소드 패턴을 적용할 수 있다.



# 긴 함수

- 짧은 함수 vs 긴 함수
    - 함수가 길 수록 더 이해하기 어렵다 vs 짧은 함수는 더 많은 문맥 전환을 필요로 하다.
    - `과거에는 ` 작은 함수를 사용하는 경우에 더 많은 서브루틴 호출로 인한 오버헤드가 있었다.
    - '작은 함수에' 좋은 이름을 사용했다면 해당 함수의 코드를 보지 않고도 이해할 수 있다.
    - 어떤 코드에 주석을 남기고 싶다면 주석 대신 함수를 만들고 함수의 이름으로 의도를 표현해보자.

- 사용할 수 있는 리팩토링 기술
    - 99%는 함수 추출하기로 해결할 수 있다.
    - 함수로 분리하면서 해당 함수로 전달해야 할 매개 변수가 많아진다면 다음 과 같이 리팩토링을 고려해 볼 수 있따.
        - 임수 변수를 질의 함수로 바꾸기(Replace Temp with Query)
        - 매개 변수 객체 만들기(Introduce Parameter Object)
        - 객체 통째로 넘기기(Preserve Whole Object)

    - 조건문 분해하기 를 사용해 조건문을 분리할 수 있다.
    - 같은 조건으로 여러개의 Switch문이 있다면 조건문을 다형성으로 바꾸기를 사용할 수 있다.
    - 반복문 안에서 여러 작업을 하고 있어서 하나의 메소드로 추출하기 어렵다면 반복분 쪼개기를 적용할 수 있따. 


## 리팩토링7 임시 변수를 질의 함수로 바꾸기
Replace Temp with Query

- 변수를 사용하면 반복해서 동일한 식을 계산하는 것을 피할 수 있고, 이름을 사용해 의미를 표현할 수도 있다.

- 긴 함수를 리팩토링할 때, 그러한 임시 변수를 함수로 추출하여 분리한다면 빼낸 함수로 전달해야 할 매개변수를 줄일 수 있다.


## 리팩토링8 매개변수 객체 만들기
introduce Parameter Object

- 같은 매개변수들이 여러 메소드에 걸쳐 나타난다면 그 매개변수들을 묶은 자료구조를 만들 수 있다. 

- 그렇게 만든 자료구조는
    - 해당 데이터간의 관계를 보다 명시적으로 나타낼 수 있다.
    - 함수에 전달할 매개변수 개수를 줄일 수 있다.
    -  도메인을 이해하는데 중요한 역할을 하는 클래스로 발전할 수도 있다.

## 리팩토링 9 객체 통째로 넘기기
Preserve Whole Object

- 어떤 한 레코드에서 구할 수 있는 여러 값들을 함수에 전달하는 경우, 해당 매개변수를 레코드 하나로 교체할 수 있다.

- 매개변수 목록을 줄일 수 있다.(향후에 추가할지도 모를 매개변수까지도)

- 이 기술을 적용하기 전에 의존성을 고려해야 한다.

- 어쩌면 해당 메소드의 위치가 적절하지 안흥ㄹ 수도 있다.

## 리팩토링 10 함수를 명령으로 바꾸기
Replace Function with Command

- 함수를 독립적인 객체인 Command로 만들어 사용할 수 있다.

- 커맨드 패턴을 적용하면 다음과 같은 장점을 취할 수 있다.
    - 부가적인 기능으로 undo기능을 만들 수도 있다.
    - 더 복잡한 기능을 구현하는데 필요한 여러 메솓르르 추가할 수 있다.
    - 상속이나 템플릿을 활용할 수도 있다.
    - 복잡한 메소드를 여러 메소드나 필드를 활용해 쪼갤 수도 있다.

- 대부분의 경우에 '커맨드' 보다는 함수를 사용하지만 커맨드 말고 다른 방법이 없는 경우에만 사용한다.


## 리팩토링 11 조건문 분해하기
Decompoe Condition

- 여러 조건에 따라 달라지는 코드를 작성하다보면 종종 긴 함수가 만들어지는 것을 목격할 수 있다.

- '조건'과 '액션' 모두 의도를 표현해야 한다.
- 기술적으로는 함수 추출하기와 동일한 리팩토링이지만 의도만 다를 뿐이다.


## 리팩토링 12 반복문 쪼개기
Split Loop

- 하나의 반복문에서 여러 다른 작업을 하는 코드를 쉽게 찾아볼 수 있다.
- 해당 반복문을 수정할 때 여러 작업을 모두 고려하며 코딩을 해야한다.
- 반복문을 여러개로 쪼개면 보다 쉽게 이해하고 수정할 수 있다.
- 성능 문제를 야기할 수 있지만, '리팩토링'은 '성능 최적화'와 별개의 작업이다. 리팩토링을 마친 이후에 성능 최적화 시도할 수 있다.


## 리팩토링 13 조건문을 다형성으로 바꾸기
Replace Conditional with Polymorphism

- 여러 타입에 따라 각기 다른 로직으로 처리해야 하는 경우에 다형성을 적용해서 조건문을 보다 명확하게 분리할 수 있다. 반복되는 switch문을 각기 다른 클래스를 만들어 제거할 수 있다.

- 공통으로 사용되는 로직은 상위클래스에 두고 달라지는 부분만 하위클래스에 둠으로써, 달라지는 부분만 강조할 수 있다.

- 모든 조건문을 다형성으로 바꿔야 하는 것은 아니다.

# 냄새4 긴 매개변수 목록

Long Parameter List 

- 어떤 함수에 매개변수가 많을수록 함수의 역할을 이해하기 어려워진다.
    - 과연 그 함수는 한가지 일을 하고 있는게 맞는가?
    - 불필요한 매개변수는 없는가?
    - 하나의 레코드로 뭉칠 수 있는 매개변수 목록은 없는가?

- 어떤 매개변수를 다른 매개변수를 통해 알아낼 수 있다면, "매개변수를 질의 함수로 바꾸기(Replace Parameter with Query)"를 사용할 수 있다. 

- 기존 자료구조에서 세부적인 데이터를 가져와서 여러 매개변수로 넘기는 대신 "객체 통째로 넘기기(Preserve Whole Object)"를 사용할 수 있다.

- 일부 매개변수들이 대부분 같이 넘겨진다면, "매개변수 객체 만들기(Introduce Parameter Object)"를 적용할 수 있다.

- 매개변수가 플래그로 사용된다면 "플래그 인수 제거(Remove Falg Argument)"를 사용할 수 있다.

- 여러 함수가 일부 매개변수를 공통적으로 사용한다면 " 여러 함수를 클래스로 묶기(Combine Functions into Class)" 를 통해 매개변수를 해당 클래스의 필드로 만들고 매서드에 전달해야 할 매개변수 목록을 줄일 수 있다. 

## 리팩토링 14 매개변수를 질의 함수로 바꾸기
Replace Parameter with Query

```
리팩토링을 하기 위해서는 반드시 테스트코드가 갖춰져 있어야 한다.
 -> 리팩토링은 기능자체를 변경하는 것이 아니다
 -> 정상적인 케이스를 만들어 통과되는지 확인을 반드시 해야한다.
```

- 함수의 매개변수 목록은 함수의 다양성을 대변하며, 짧을수록 이해하기 좋다.
- 어던 한 매개변수를 다른 매개변수를 통해 알아낼 수 있다면 "중복 매개변수"라 생각할 수 있다.

- 매개변수에 값을 전달하는 것은 "함수를 호출하는 쪽"의 책임이다. 가능하면 함수를 호출하는 쪽의 책임을 줄이고 함수 내부에서 책임지도록 노력한다. 

- "임시 변수를 질의 함수로 바꾸기"와 "함수 선언 변경하기"를 통해 이 리팩토링을 적용한다. 

    - 변수를 사용하면 이름을 사용해 의미를 표현할 수 있다.
    - 임시 변수를 함수로 추출하기
## 리팩토링15 플래그 인수 제거하기
Remove Flag Argument

```
플래그가 보통 함수에 매개변수로 전달해서 함수 내부의 로직을 분기하는지 사용한다.
 -> 조건문 분해하기 사용하기

* 플래그가 들어잇는 메소드는 좋지 않다.
 - 너무 많은 플래그가 있다면 그 메소드는 너무 많은 역할을 하고 있는 것이다.
 - 플래그가 하나 들어있다면 그 메소드가 하는 의미를 파악하기 힘들다.
    -> 조건문 분해하기
```

- 플래그는 보통 함수에 매개변수로 전달해서, 함수 내부의 로직을 분기하는데 사용한다.

- 플래그를 사용한 함수는 차이를 파악하기 어렵다.
    - bookConcert(customer, false) , bookConcert(customer, true)

    - bookConcert(customer), premiumBookConcert(customer)

- 조건문 분해하기(Decompose condition)를 활용할 수 있다.

## 리팩토링 16 여러 함수를 클래스로 묶기
Combine Functions into Class

- 비슷한 매개변수 목록을 여러 함수에서 사용하고 있다면 해당 메소드를 모아서 클래스를 만들 수 있다.

- 클래스 내부로 메소드를 옮기고, 데이터를 필드로 만들면 메소드에 전달해야 하는 매개변수 목록도 줄일 수 있다.
