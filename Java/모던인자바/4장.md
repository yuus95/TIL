스트림의 특징 
```
선언형: 더 간결하고 가독성이 좋아진다.
    -> 데이터를 처리하는 임시 구현 코드 대신 질의로 표현할 수 있다.
조립할 수 있음: 유연성이 좋아진다.
    -> 특정 스레드 모델에 제한되지 않고 자유롭게 어떤 상황에서든 사용할 수 있다. 
병렬화: 성능이 더 좋아진다.
    -> 멀티 스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.
```

스트림 정의 : 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
- 특정 요소 형식으로 이루저니 연속된 값집합의 인터페이스를 제공한다.
- 컬렉션은 시간과 공간의 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다.
    - 스트림은 계산식이 주를 이룬다.
- 소스 : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다			    정렬된 컬렉션으로 스트림을 생성하면 정렬이 그대로 유지된다.
                    (리스트로 스트림을 만들면 스트림의 요소는 리스트의 요소와 같은 순서를 유지한다.)
    
    - 데이터 처리 연산: 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스
                                    와 비슷한 연산을 지원한다.  스트림 연산은 순차적으로 또는 병렬로 실행할 
                                    수 있다.

파이프라이닝: 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록
					스트림 자신을 반환한다. 그 덕분에 Lazineses(게으름),short-circuiting(쇼트서킷)
					같은 최적화도 얻을 수 있다.

내부 반복: 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.


## 스트림과 컬렉션
- 데이터를 언제 계산하느냐가 컬렉션과 스트림의 가장 큰 차이이다. 
    - 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다. -> 컬렉션의
        모든 요소는 컬렉션에 추가되기 전에 계산되어야 한다.
        - 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조이다. -> 스트림에 요소를 추가하거나 
            스트림에서 요소를 제거할 수 없다.
            - 적극적 생성 : 모든 값을 계산할 때까지 기다린다.
            - 게으른 생성 : 필요할 때만 값을 계산한다는 의미.
        - 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다.
            - 외부 반복에서는 병렬성을 스스로 관리해야한다.(병렬성을 포기하든지 아니면synchronized로 시작하는 힘들고 긴 전쟁을 시작해야 한다.)


## 중간연산
|연산|형식|반환형식|연산의 인수| 함수 디스크립터|
|---|---|-----|-------|-----|
|filter| 중간연산|Stream<T>| Predicate<T> | T -> boolean |
|map| 중간 연산| Stream<R> | Function<T,R> | T -> R |
|limit | 중간연산 | Stream<T>| ||
| sorted | 중간연산 | Stream<T> | Comparator<T> | (T,T) -> int | 
| distinct | 중간연산 | Stream<T>  | |

## 최종연산 
|연산|형식|반환형식|목적|
|---|---|-----|-------|
|forEach| 최종 연산|void | Predicate<T>
|count| 최종 연산| Long(generic) | 스트림의 요소 개수를 반환한다.
|collect | 최종 연산 | | 스트림을 리듀스해서 리스트, 맵 정수 형식의 컬렉션을 만든다.

## 최종 정리

- 스트림은 소스에서 추출된 연속 요소로 데이터 처리 연산을 지원한다.
- 스트림은 내부 반복을 지원한다. 내부 반복은 filter, map, srted등의 연산으로 반복을 추상화 한다.
- 스트림에는 중간 연산과 최종 연산이 있다.
- 중간 연산은 filter와 map 처럼 스트림을 반환하면서 다른 연산과 연결되는 연산이다. 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 중간 연산으로는 ***어떤 결과도 생성할 수 없다.***
- forEach나 count처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 한다.
- 스트림의 요소는 요청할 때 lazily 계산된다.

## loop fusion , 쇼트서킷 내용이해하기