## 1장

- mysql 과 maria Db 의 데이터베이스 사용 점유율은 합쳐서 60프로이다(반이상을 점유하고있다. (mysql 55%))

- mysql에는 아직 중첩 루프 조인 알고리즘만 사용한다.  (오라클은 해시 조인, 병렬 조합 조인 가능)
- 상대적으로 낮은 메모리 사용

### mysql 문법(oracle 과 혼동할 수 있는 문법들 정리)

- IFNULL(열명, 대쳇 값) : 열명이 널값인 경우 대쳇값으로 반환
- IF(조건식,'참 값', '거짓 값'): 조건이 참이면 참값, 거짓이면 거짓 값
- SUBSTRING('abcdefg',2,3) : 문자열에서 2번째(b)부터 3개를 잘라서 가져온다.
- now() : 현재시간
- 날짜형식 변환방법
    - SELECT DATE_FORMAT(NOW*(), '%Y%m%d %H%i%s') AS date;
- autoincrement라는 개념 숫자 자동증가 컬럼을 생성할 수 있다. (mariadb는 sequence 기능과 autoincrement 기능 둘 다 사용 가능)
- LIMIT : 페이징 기능 때 LIMIT 키워드 사용  


## 2장

Mysql의 성능을 개선하기 위해서는 필수적으로 알아야 하는 개념이 있는데 그 개념들을 간단하게 정리한다.

그 개념들이 왜 필요한지 택시이야기를 통해 이해를 시켜주었고,그 예시를 통해 빠르게 이해할 수 있도록 도움을 얻었다. 

(간단 요약:한국 택시의 택시를 타기 위해 한국어로 말을 해야하고, 한국에 있는 지역을 말해야 한다. 기사는 그 지역을 최소한의 시간으로 가기 위해 최적의 루트를 검색한다.)

- 파서: (Mysql 엔진에 포함되는 오브젝트) 요청 들어온 SQL문을 트리구조를 형성한다. 이 때 문법 오류가 있는지 확인한다.(문법적으로 오류가 있는지 판단하여 에러 반환)

- 전처리기: (Mysql 엔진에 포함되는 오브젝트) 파서에서 생성한 트리를 토대로 SQL 구조적 문제파악(실제로 테이블이 있는지, 조회할 수 있는 권한이 있는지.. 등등)

- 옵터마이저: 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화한다. 
실행계획을 수립하여 인덱스를 사용할지 판단한다. 
    - 실행계획을 수립하는 것 자체가 리소스를 먹는 행위이다. 시간과 리소스에 제한을 두고 실행 계획을 산정해야 하고, 모든 계획이 최적화가 되는 것은 아니다. 
- 엔진 실행기: (Mysql 엔진과 스토리지 엔진에 걸쳐 있는 오브젝트) 실행 계획을 참고하여 스토리지 엔진에서 데이터를 가져온다. 
    - mysql 엔진의 부하를 줄일려면 스토리지 엔진에서 가져오는 데이터양을 줄여야 한다. 



### DB 오브젝트 용어

- 테이블: 하나의 데이터의 집합(2차원 배열 형태) -> 모든 행의 집합
- 로우: 동일한 구조이ㅡ 데티터 항목들의 집합을 가리킨다. 
- 컬럼: 하나의 데이터 필드에 대한 값들의 집합?


- 뷰: 가상 테이블
    - 뷰를 사용하는 이유는 테이블의 모든 데이터를 보여주는게 아니라 일부의 데이터만 보여주고 싶을 떄 주로 사용한다. 
    - 일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문이다.
    - 여러 개의 테이블을 병합해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로ㅓ써 일관된 성능을 제공할 수 있다. 

- 기본 키: 
    - 클러스터형 인덱스로 작동한다. (기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다)
    - 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근할 수 있따. 
- 외래 키: 다른 테이블의 키를 조한다. 
- 인덱스: 키 값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트이다. 
    - 고유 인덱스: 인덱스 키 값이 중복되어 저장될 수 없다.
    - 비고유 인덱스: 인덱스 키 값이 중복되어 저장될 수 있다.
    - 기본 키와의 차이점은 NULL 값 허용이다.(기본키는 널값 허용 X)


### 서브 쿼리 용어

서브 쿼리는 사용되는 위치마다 명칭이 다르다. (Select,where,from 등등), 명칭은 달라도 반환하는 형태에 따라 비슷한 의미를 가질 수 있다.


- 스칼라 서브 쿼리: 주로 Select 절에서 많이 사용되며 반환값이 1개인 경우를 의미한다. 
    - 주로 집계함수와 같이 사용한다. (sum, count)


- 인라인 뷰: from 내부에서 일시적으로 뷰를 생성하는 방식
    - 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성한다. 

- 중첩 서브 쿼리:WHERE 절에 있는 SELECT 절
    - 일반적인 조건절에 사용하지 않고 특정 범위내에 조건 절을 이용할 때 주로 사용한다.

### 메인 쿼리와의 관계성에 따른 SQL 용어
서브쿼리는 그 자체가 독립적인 형태로 존재할 수도 있고, 메인 쿼리와 끈끈한 관계를 유지할 수 있다. 

- 비상관 서브쿼리
    - 메인 쿼리와 서브 쿼리간에 관계가 없다.  
    - 서브 쿼리 실행 -> 메인 쿼리순으로 실행된다.
    - 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합이 작동할 수 있다.
- 상관 서브쿼리
    - 메인쿼리와 서브쿼리가 `관계성 있음`을 의미한다. 
    - 서브쿼리가 실행되기 위해서는 메인 쿼리의 값을 받아야 하므로 끈근한 관계가 유지된다.)
        - `스칼라 서브쿼리`와 `중첩 서브쿼리` 일 때 발생한다.
    - 실행순서는 메인쿼리 -> 서브 쿼리 -> 메인쿼리


### 반환 결과에 따른 SQL 용어
서브쿼리의 결과 유형을 수치적 기준으로 구분할 수 있다. 
- 행이 1개 : 단일 행 서브 쿼리
    - 스칼라 서브쿼리와 동일하다
- 행이 2개이상 : 다중행 서브쿼리
    - 서브 쿼리 결과가 여러 건의 행으로 반횐 되는 쿼리이다. (중첩 서브쿼리에서 IN절로 받는다.)
- 행과 열이 2개 이상: 다중열 서브 쿼리
    - IN구문과 함께 사용한다.


### 조인 알고리즘 용어

Mysql에서는 여러개의 테이블을 조인해서 사용할 때 조인되는 테이블을 동시에 접근할 수 없어서 데이터에 접근하는
우선순위가 존재한다.

우선 참조하는 테이블을 `드라이빙 테이블` 이라고 하고 후에 참조되는 테이블을 `드리븐 테이블` 이라고 한다.

적은 결과가 반환 될 것으로 예상되는 테이블을 드라이빙 테이블로 지정해야하고, 조건절의 열이 인덱스로 설정되도록 구성해야 한다.  ( JPA N + 1 문제와 비슷한 것 같다.)

- 중첩 루프 조인 (nested loop join)
    - 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력하게 한다. 

    - 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 `랜덤 엑세스`가 발생한다.
        - 랜덤엑세스란 순차적으로 데이터를 찾는 것이 아닌 임의의 순서로 접근하여 찾는다는 의미
        - 비고유 인덱스일 경우에 해당
        - 액세스 범위를 좁히는 방향으로 인덱스를 설계해야 한다. 

- 블록 중첩 루프 조인
    - 중첩 루프 조인의 효율성을 높이고자 탄생했다.
    - 드라이빙 테이블에 대해 조인 버퍼라는 개념을 도입하여 조인 성능을 향상 시킬 수 있었다.
        - 드라이빙 테이블에서 조건에 해당하는 로우를 조인 버퍼에 넣은 뒤, 드리븐 테이블에서 조인 버퍼에 있는 로우와 매칭하여 찾는다. 

- 배치 키 엑세스 조인 
    - 접근할 데이터를 미리 예상하고 가져오는데 착안한 조인 알고리즘
        - 중첩 루프 조인 방식에서 나타나는 랜덤 엑세스 단점을 해결하기 위해 고안

- 해시 조인
    - 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다. 해시값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않는다. 
    


### 튜닝 용어

- 오브젝트 스캔 유형
    - 테이블 스캔 : 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형
        - 테이블 풀 스캔: 로우를 처음부터 끝까지 조회한다.
    - 인덱스 스캔: 인덱스로 테이블 데이터를 찾아가는 유형
        - 인덱스 풀 스캔: 인덱스를 처음부터 끝까지 수행하는 방식
            - 인덱스는 테이블보다 상대적으로 적은 양을 차지해서 테이블 풀 스캔 보다 유리하다. 
        - 인덱스 고유 스캔: 고유 인덱스를 이용하여 데이터를 조회하는 방식
        - 인덱스 루스 스캔: 인덱스의 필요한 부분들만 골라 스캔하는 방식     
            - GROUP BY 구문이나, MAX(), MIN() 함수가 포함되면 작동한다. 

        - 인덱스 병합 스캔



- 디스크 접근 방식<br>
Mysql은 원하는 데이터를 찾으려고 데이터가 저장된 스토리지의 페이지에 접근한다. 이 때 페이지는 데이터를 검색하는 최소 단위를 의미한다. 
    - 시퀀셜 엑세스
        - 페이지를 차례대로 읽는 방법을 의미한다. (순차 접근 방식)
        - 디스크 헤더의 움직임을 최소화하여 작업 시간과 리소스 점유 비용을 줄일 수 있다.
        - `테이블 풀 스캔`일 때는 인접한 페이지를 여러 개 읽느 ㄴ다주 ㅇ페이지 읽기 방식으로 수행한다.

    - 랜덤 엑세스  
        - 원하는 페이지를 임의로 열어서 확인한다. 
        - 디스크 헤더가 정해진 순서 없이 이동하는 만큼 디스크의 물리적인 움직임이 필요하고 다중 페이지 읽기가 불가능하다. 
        - 최소한의 페이지에 접근할 수 있도록 인덱스를 활용하여 튜닝 해야 한다. 

- 조건 유형 <br>
    SQL 문의 WHERE 절 조건문 기준으로 데이터가 저장된 디스크에 접근하게 된다.  이 떄 
    `엑세스` 하는 조건문으로 데이터를 가져오고, 가져오 ㄴ데이터에서 다시 한번 출력할 데이터만 추출한다 

    - 엑세스 조건
        - 데이터를 검색하는 조건을 의미한다. 
        - 어떻게 접근할 것인지를 다루는 엑세스 조건은 튜닝에서 가장 중요한 핵심 사항이다. 
    - 필터 조건
        - 엑세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로, 추가로 불필요한 데이터를 제거하거나 가공하는 조건이다. 
        - 필터 조건에 따라 필터링할 데이터가 없다면 훌륭한 SQL문이다. 

- 선택도 <br>
특정 열을 기준으로 조건절에 따라 선택되는 데이터 비율이다. 
    - 중복도
        -  1 / count(Distinct(열 명)) / 전체 카운터 
        - 선택도가 낮을 수록 원하는 데이터만 가져왔다는 걸 알 수 있다. 

- 카디널리티
    - 하나의 데이터 유형으로 정의되는 데이터 행의 개수 
    - 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 자주 활용한다. 
    - 전체 데이터 건수 * 선택도
        - 중복되는 값이 높으면 카디널리티가 낮다.

- 힌트 
    - 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는것

- 콜레이션
    - 특정 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙을 의미한다. 



## 3장


### select Type

```
# ID 실행 순서를 표시한다. 같은 아이디값이존재하면 조인을 이용한 것 이라고 볼 수 있다.

# SIMPLE : 쿼리에 UNION 이나 서브쿼리가 존재하지 않을 경우를 의미한다.

# PRIMARY: 쿼리에 UNION 이나 서브쿼리가 존재할 때 표시된다. (서브쿼리를 감싸는 외부쿼리거나, UNION에서 첫 번째 SQL문을 표시)

# SUBQUERY: 독립적으로 수행되는 서브쿼리를 의미한다. (SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브 쿼리일 경우에 해당한다.)

# DERIVED: FROM 절에서 작성된 서브쿼라룰 의미한다. (인라인뷰)

# UNION: UNION 및 UNION ALL 구문으로 합쳐진 SELECT문에서 PRIMARY구문을 제외한 나머지 부분을 의미한다.

# UNION RESULT: UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력
    # 중복이 없는 유일한 속성을 가지므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거친다.
    # SELECT문이 중복되지 않는 결과가 보장될 때는 UNION ALL 구문으로 변경하여 SQL튜닝을 수행한다.
# DEPENDENT SUBQUERY: UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우 (UNION의 PRIMARY 키일 때 적용)
    # 메인 테이블로부터 값을 하나씩 공급받는 구조이므로 성능적으로 불리하여 SQL문이 튜닝 대상이 된다.

# DEPENDENT UNION : (SubQuery의 UNION의 2번쨰 쿼리부터 적용) DEPENDENT SUBQUERY와 비슷한 맥락이다.

# UNCACHEABLE SUBQUERY: 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
    # 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수가 포함되거나
    # RAND(), UUID() 함수등을 사용하여 매번 조회 시마다 결과가 달라지는 경우에 해당한다.
    # 자주 호출되는 SQL문이라면  메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 SQL 튜닝을 검토할 수 있다.

# MATERIALIZED : IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형
    
```