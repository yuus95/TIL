## 1장

- mysql 과 maria Db 의 데이터베이스 사용 점유율은 합쳐서 60프로이다(반이상을 점유하고있다. (mysql 55%))

- mysql에는 아직 중첩 루프 조인 알고리즘만 사용한다.  (오라클은 해시 조인, 병렬 조합 조인 가능)
- 상대적으로 낮은 메모리 사용

### mysql 문법(oracle 과 혼동할 수 있는 문법들 정리)

- IFNULL(열명, 대쳇 값) : 열명이 널값인 경우 대쳇값으로 반환
- IF(조건식,'참 값', '거짓 값'): 조건이 참이면 참값, 거짓이면 거짓 값
- SUBSTRING('abcdefg',2,3) : 문자열에서 2번째(b)부터 3개를 잘라서 가져온다.
- now() : 현재시간
- 날짜형식 변환방법
    - SELECT DATE_FORMAT(NOW*(), '%Y%m%d %H%i%s') AS date;
- autoincrement라는 개념 숫자 자동증가 컬럼을 생성할 수 있다. (mariadb는 sequence 기능과 autoincrement 기능 둘 다 사용 가능)
- LIMIT : 페이징 기능 때 LIMIT 키워드 사용  


## 2장

Mysql의 성능을 개선하기 위해서는 필수적으로 알아야 하는 개념이 있는데 그 개념들을 간단하게 정리한다.

그 개념들이 왜 필요한지 택시이야기를 통해 이해를 시켜주었고,그 예시를 통해 빠르게 이해할 수 있도록 도움을 얻었다. 

(간단 요약:한국 택시의 택시를 타기 위해 한국어로 말을 해야하고, 한국에 있는 지역을 말해야 한다. 기사는 그 지역을 최소한의 시간으로 가기 위해 최적의 루트를 검색한다.)

- 파서: (Mysql 엔진에 포함되는 오브젝트) 요청 들어온 SQL문을 트리구조를 형성한다. 이 때 문법 오류가 있는지 확인한다.(문법적으로 오류가 있는지 판단하여 에러 반환)

- 전처리기: (Mysql 엔진에 포함되는 오브젝트) 파서에서 생성한 트리를 토대로 SQL 구조적 문제파악(실제로 테이블이 있는지, 조회할 수 있는 권한이 있는지.. 등등)

- 옵터마이저: 전달된 파서 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정을 단순화한다. 
실행계획을 수립하여 인덱스를 사용할지 판단한다. 
    - 실행계획을 수립하는 것 자체가 리소스를 먹는 행위이다. 시간과 리소스에 제한을 두고 실행 계획을 산정해야 하고, 모든 계획이 최적화가 되는 것은 아니다. 
- 엔진 실행기: (Mysql 엔진과 스토리지 엔진에 걸쳐 있는 오브젝트) 실행 계획을 참고하여 스토리지 엔진에서 데이터를 가져온다. 
    - mysql 엔진의 부하를 줄일려면 스토리지 엔진에서 가져오는 데이터양을 줄여야 한다. 



### DB 오브젝트 용어

- 테이블: 하나의 데이터의 집합(2차원 배열 형태) -> 모든 행의 집합
- 로우: 동일한 구조이ㅡ 데티터 항목들의 집합을 가리킨다. 
- 컬럼: 하나의 데이터 필드에 대한 값들의 집합?


- 뷰: 가상 테이블
    - 뷰를 사용하는 이유는 테이블의 모든 데이터를 보여주는게 아니라 일부의 데이터만 보여주고 싶을 떄 주로 사용한다. 
    - 일부 데이터에 대해서만 데이터를 공개하고, 노출에 민감한 데이터에 대해서는 제약을 설정할 수 있는 보안성 때문이다.
    - 여러 개의 테이블을 병합해서 활용할 때는 성능을 고려한 최적화된 뷰를 생성함으로ㅓ써 일관된 성능을 제공할 수 있다. 

- 기본 키: 
    - 클러스터형 인덱스로 작동한다. (기본 키의 구성 열 순서를 기준으로 물리적인 스토리지에 데이터가 쌓인다)
    - 기본 키를 활용하여 인덱스 스캔을 수행하면 테이블 데이터에 더 빠르게 접근할 수 있따. 
- 외래 키: 다른 테이블의 키를 조한다. 
- 인덱스: 키 값으로 실제 데이터 위치를 식별하고 데이터 접근 속도를 높이고자 생성되는, 키 기준으로 정렬된 오브젝트이다. 
    - 고유 인덱스: 인덱스 키 값이 중복되어 저장될 수 없다.
    - 비고유 인덱스: 인덱스 키 값이 중복되어 저장될 수 있다.
    - 기본 키와의 차이점은 NULL 값 허용이다.(기본키는 널값 허용 X)


### 서브 쿼리 용어

서브 쿼리는 사용되는 위치마다 명칭이 다르다. (Select,where,from 등등), 명칭은 달라도 반환하는 형태에 따라 비슷한 의미를 가질 수 있다.


- 스칼라 서브 쿼리: 주로 Select 절에서 많이 사용되며 반환값이 1개인 경우를 의미한다. 
    - 주로 집계함수와 같이 사용한다. (sum, count)


- 인라인 뷰: from 내부에서 일시적으로 뷰를 생성하는 방식
    - 인라인 뷰의 결과는 내부적으로 메모리 또는 디스크에 임시 테이블을 생성한다. 

- 중첩 서브 쿼리:WHERE 절에 있는 SELECT 절
    - 일반적인 조건절에 사용하지 않고 특정 범위내에 조건 절을 이용할 때 주로 사용한다.

### 메인 쿼리와의 관계성에 따른 SQL 용어
서브쿼리는 그 자체가 독립적인 형태로 존재할 수도 있고, 메인 쿼리와 끈끈한 관계를 유지할 수 있다. 

- 비상관 서브쿼리
    - 메인 쿼리와 서브 쿼리간에 관계가 없다.  
    - 서브 쿼리 실행 -> 메인 쿼리순으로 실행된다.
    - 옵티마이저에 따라 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합이 작동할 수 있다.
- 상관 서브쿼리
    - 메인쿼리와 서브쿼리가 `관계성 있음`을 의미한다. 
    - 서브쿼리가 실행되기 위해서는 메인 쿼리의 값을 받아야 하므로 끈근한 관계가 유지된다.)
        - `스칼라 서브쿼리`와 `중첩 서브쿼리` 일 때 발생한다.
    - 실행순서는 메인쿼리 -> 서브 쿼리 -> 메인쿼리


### 반환 결과에 따른 SQL 용어
서브쿼리의 결과 유형을 수치적 기준으로 구분할 수 있다. 
- 행이 1개 : 단일 행 서브 쿼리
    - 스칼라 서브쿼리와 동일하다
- 행이 2개이상 : 다중행 서브쿼리
    - 서브 쿼리 결과가 여러 건의 행으로 반횐 되는 쿼리이다. (중첩 서브쿼리에서 IN절로 받는다.)
- 행과 열이 2개 이상: 다중열 서브 쿼리
    - IN구문과 함께 사용한다.


### 조인 알고리즘 용어

Mysql에서는 여러개의 테이블을 조인해서 사용할 때 조인되는 테이블을 동시에 접근할 수 없어서 데이터에 접근하는
우선순위가 존재한다.

우선 참조하는 테이블을 `드라이빙 테이블` 이라고 하고 후에 참조되는 테이블을 `드리븐 테이블` 이라고 한다.

적은 결과가 반환 될 것으로 예상되는 테이블을 드라이빙 테이블로 지정해야하고, 조건절의 열이 인덱스로 설정되도록 구성해야 한다.  ( JPA N + 1 문제와 비슷한 것 같다.)

- 중첩 루프 조인 (nested loop join)
    - 드라이빙 테이블의 데이터 1건당 드리븐 테이블을 반복해 검색하며 최종적으로 양쪽 테이블에 공통된 데이터를 출력하게 한다. 

    - 인덱스를 이용해 테이블의 데이터를 찾아가는 과정에서 임의 접근 방식인 `랜덤 엑세스`가 발생한다.
        - 랜덤엑세스란 순차적으로 데이터를 찾는 것이 아닌 임의의 순서로 접근하여 찾는다는 의미
        - 비고유 인덱스일 경우에 해당
        - 액세스 범위를 좁히는 방향으로 인덱스를 설계해야 한다. 

- 블록 중첩 루프 조인
    - 중첩 루프 조인의 효율성을 높이고자 탄생했다.
    - 드라이빙 테이블에 대해 조인 버퍼라는 개념을 도입하여 조인 성능을 향상 시킬 수 있었다.
        - 드라이빙 테이블에서 조건에 해당하는 로우를 조인 버퍼에 넣은 뒤, 드리븐 테이블에서 조인 버퍼에 있는 로우와 매칭하여 찾는다. 

- 배치 키 엑세스 조인 
    - 접근할 데이터를 미리 예상하고 가져오는데 착안한 조인 알고리즘
        - 중첩 루프 조인 방식에서 나타나는 랜덤 엑세스 단점을 해결하기 위해 고안

- 해시 조인
    - 조인에 참여하는 각 테이블의 데이터를 내부적으로 해시값으로 만들어 내부 조인을 수행한다. 해시값으로 내부 조인을 수행한 결과는 조인 버퍼에 저장되므로 조인 열의 인덱스를 필수로 요구하지 않는다. 
    


### 튜닝 용어

- 오브젝트 스캔 유형
    - 테이블 스캔 : 인덱스를 거치지 않고 바로 디스크에 위치한 테이블 데이터에 접근하는 유형
        - 테이블 풀 스캔: 로우를 처음부터 끝까지 조회한다.
    - 인덱스 스캔: 인덱스로 테이블 데이터를 찾아가는 유형
        - 인덱스 풀 스캔: 인덱스를 처음부터 끝까지 수행하는 방식
            - 인덱스는 테이블보다 상대적으로 적은 양을 차지해서 테이블 풀 스캔 보다 유리하다. 
        - 인덱스 고유 스캔: 고유 인덱스를 이용하여 데이터를 조회하는 방식
        - 인덱스 루스 스캔: 인덱스의 필요한 부분들만 골라 스캔하는 방식     
            - GROUP BY 구문이나, MAX(), MIN() 함수가 포함되면 작동한다. 

        - 인덱스 병합 스캔



- 디스크 접근 방식<br>
Mysql은 원하는 데이터를 찾으려고 데이터가 저장된 스토리지의 페이지에 접근한다. 이 때 페이지는 데이터를 검색하는 최소 단위를 의미한다. 
    - 시퀀셜 엑세스
        - 페이지를 차례대로 읽는 방법을 의미한다. (순차 접근 방식)
        - 디스크 헤더의 움직임을 최소화하여 작업 시간과 리소스 점유 비용을 줄일 수 있다.
        - `테이블 풀 스캔`일 때는 인접한 페이지를 여러 개 읽느 ㄴ다주 ㅇ페이지 읽기 방식으로 수행한다.

    - 랜덤 엑세스  
        - 원하는 페이지를 임의로 열어서 확인한다. 
        - 디스크 헤더가 정해진 순서 없이 이동하는 만큼 디스크의 물리적인 움직임이 필요하고 다중 페이지 읽기가 불가능하다. 
        - 최소한의 페이지에 접근할 수 있도록 인덱스를 활용하여 튜닝 해야 한다. 

- 조건 유형 <br>
    SQL 문의 WHERE 절 조건문 기준으로 데이터가 저장된 디스크에 접근하게 된다.  이 떄 
    `엑세스` 하는 조건문으로 데이터를 가져오고, 가져오 ㄴ데이터에서 다시 한번 출력할 데이터만 추출한다 

    - 엑세스 조건
        - 데이터를 검색하는 조건을 의미한다. 
        - 어떻게 접근할 것인지를 다루는 엑세스 조건은 튜닝에서 가장 중요한 핵심 사항이다. 
    - 필터 조건
        - 엑세스 조건을 이용해 MySQL 엔진으로 가져온 데이터를 기준으로, 추가로 불필요한 데이터를 제거하거나 가공하는 조건이다. 
        - 필터 조건에 따라 필터링할 데이터가 없다면 훌륭한 SQL문이다. 

- 선택도 <br>
특정 열을 기준으로 조건절에 따라 선택되는 데이터 비율이다. 
    - 중복도
        -  1 / count(Distinct(열 명)) / 전체 카운터 
        - 선택도가 낮을 수록 원하는 데이터만 가져왔다는 걸 알 수 있다. 

- 카디널리티
    - 하나의 데이터 유형으로 정의되는 데이터 행의 개수 
    - 현업에서는 전체 행에 대한 특정 열의 중복 수치를 나타내는 지표로 자주 활용한다. 
    - 전체 데이터 건수 * 선택도
        - 중복되는 값이 높으면 카디널리티가 낮다.

- 힌트 
    - 데이터를 빨리 찾을 수 있게 추가 정보를 전달하는것

- 콜레이션
    - 특정 문자셋으로 데이터베이스에 저장된 값을 비교하거나 정렬하는 작업의 규칙을 의미한다. 



## 3장

### ID : 실행 순서를 표시한다. 같은 아이디값이존재하면 조인을 이용한 것 이라고 볼 수 있다.


### Select Type

```


# SIMPLE : 쿼리에 UNION 이나 서브쿼리가 존재하지 않을 경우를 의미한다.

# PRIMARY: 쿼리에 UNION 이나 서브쿼리가 존재할 때 표시된다. (서브쿼리를 감싸는 외부쿼리거나, UNION에서 첫 번째 SQL문을 표시)

# SUBQUERY: 독립적으로 수행되는 서브쿼리를 의미한다. (SELECT 절의 스칼라 서브쿼리와 WHERE 절의 중첩 서브 쿼리일 경우에 해당한다.)

# DERIVED: FROM 절에서 작성된 서브쿼라룰 의미한다. (인라인뷰)

# UNION: UNION 및 UNION ALL 구문으로 합쳐진 SELECT문에서 PRIMARY구문을 제외한 나머지 부분을 의미한다.

# UNION RESULT: UNION ALL이 아닌 UNION 구문으로 SELECT 절을 결합했을 때 출력
    # 중복이 없는 유일한 속성을 가지므로 각 SELECT 절에서 데이터를 가져와 정렬하여 중복 체크하는 과정을 거친다.
    # SELECT문이 중복되지 않는 결과가 보장될 때는 UNION ALL 구문으로 변경하여 SQL튜닝을 수행한다.
# DEPENDENT SUBQUERY: UNION 또는 UNION ALL을 사용하는 서브쿼리가 메인 테이블의 영향을 받는 경우 (UNION의 PRIMARY 키일 때 적용)
    # 메인 테이블로부터 값을 하나씩 공급받는 구조이므로 성능적으로 불리하여 SQL문이 튜닝 대상이 된다.

# DEPENDENT UNION : (SubQuery의 UNION의 2번쨰 쿼리부터 적용) DEPENDENT SUBQUERY와 비슷한 맥락이다.

# UNCACHEABLE SUBQUERY: 메모리에 상주하여 재활용되어야 할 서브쿼리가 재사용되지 못할 때 출력되는 유형
    # 해당 서브쿼리 안에 사용자 정의 함수나 사용자 변수가 포함되거나
    # RAND(), UUID() 함수등을 사용하여 매번 조회 시마다 결과가 달라지는 경우에 해당한다.
    # 자주 호출되는 SQL문이라면  메모리에 서브쿼리 결과가 상주할 수 있도록 변경하는 방향으로 SQL 튜닝을 검토할 수 있다.

# MATERIALIZED : IN 절 구문에 연결된 서브쿼리가 임시 테이블을 생성한 뒤, 조인이나 가공 작업을 수행할 때 출력되는 유형
    
```


### table

테이블 명을 표시하는 항목 실행 계획 정보에서 테이블명이나 테이블 별칭을 출력하여,
서브쿼리나 임시 테이블을 만들어 별도의 작업을 수행할 때는 (subquery 나 derived) 로 출력된다. 

### partitions

실행 계획의 부가 정보로, 데이터가 저장된 논리적인 영역을 표시하는 항목이다.

### type
테이블의 데이터를 어떻게 찾을지에 관한 정보를 제공하는 항목이다. 테이블을 처음부터 끝까지 전부 확인할지 아니면
인덱스를 통해 바로 데이터를 찾아갈지 등을 해석할 수 있다. 

- system: 테이블에 데이터가 없거나 한 개만 있는 경우로 성능상 최상의 type이다.

- const: 조회되는 데이터가 단 1건일 때 출력되는 유형으로 성능상 매우 유리한 방식이다. 
    - 고유 인덱스나 기본키를 사용하여 단 1건의 데이터에만 접근하면 되므로 속도나 리소스 사용 측면에서 지향해야 할 타입이다. 

- eq_ref: 조인이 수행될 때 드리븐 테이블의 데이터에 접근하면 고유 인덱스 또는 기본 키로 단 1건의 데이터를 조회하는 방식이다. 
    - 드라이빙 테이블과 조인 키가 드리븐 테이블에 유일하므로 조인이 수행될 때 성능상 가장 유리한 경우


- ref: 조인을 수행할 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우를 의미 
    - 드라이빙 테이블과 드리븐 테이블에 조인을 수행하면 일대다 관계가 되므로 드라이밍 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재한다. 


- ref_or_null
    - ref 유형과 유사하지만 IS NULL 구문에 대해 인덱스를 활용하도록 최적화된 방식이다. 
    - NULL에 대해서도 인덱슬르 활용하여 검색할 수 있으며, 이 때 NULL은 가장 앞쪽에 정렬된다. 
    

- range : 테이블 내의 연속된 데이터 범위를 조회하는 유형으로 =,<>, >, >=, <, <=, IS NULL , <=>,BETWEEN, IN  연산을 통해 범위 스캔을 수행하는 방식이다. 
    - 주어진 데이터 범위 내에서 행 단위로 스캔하지만, 스캔할 범위가 넓으면 성능 저하의 요인이 될 수 있으므로 
    튜닝 검토 대상이된다. 

- fulltext: 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스를 사용하여 데이터에 접근하느 방시깅다.

- index_merge : 결합된 인덱스들이 동시에 사용되는 유형이다. 특정 테이블에 생성된 두 개 이상의 인덱스가 
병합되어 동시에 적용된다. 

- index: type항목의 index 유형은 인덱스 풀 스캔을 의미한다. 물리적인 인덱스 블록을
처음부터 끝까지 훑는 방식

- ALL: 테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식에 해당되는 유형이다. 
    - ALL유형은 활용할 수 있는 인덱스가 없거나, 인덱스를 활용하는 게 오히려 비효율적이라고 판단됐을 때 사용한다. 

    - 전체 테이블 중 10 ~ 20% 이상 분량의 데이터를 조회할 때는 ALL 유형이 오히려 성능상 유리할 수도 있다. 

### possible_key : 실제로 사용하는키가 아니라 사용될 수 있는 키들을 보여준다?
- SQL문을 최적화하고자 사용할 수 있는 인덱스 목록을 출력한다. 
- 실제 사용한 인덱스가 아닌, 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여준다. 

### key: 옵티마이저가 SQL문을 최적화하고자 사용한 기본 키 또는 인덱스명을 의미한다. 
-  어느 인덱스로 데이터를 검색했는지 확인할 수 있다.
- 비효율적인 인덱스를 사용했거나, 인덱스 자체를 사용하지 않았을 경우 튜닝대상이다. 

### key_len: 사용한 인덱스의 바이트 수를 의미한다. 
- 인덱스를 사용할 때는 인덱스 전체를 사용하거나 일부 인덱스만 사용한다. 
- 왜 varchar는 단위당 3바이트를 먹는지 이해할 수 없다.
    - varchar(50) --> where 직급명 = 'Manager' -> 159바이트 사용 와이?

### row:  SQL문을 수행하고자 접근하는 데이트의 모든 행 수를 나타내는 예측 항목
- 디스크에서 데이터 파일을 읽고 메모리에서 처리해야 할 행 수를 예상하는 값
- SQL문의 최종 결과 건수와 비교해 rows수가 크게 차이 날 때는 불필요하게 MySQL엔진까지
데이터를 많이 가져왔다는 뜻이므로 튜닝 대상이다. 

### filtered : DB엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도의 비율로 데이터를 제거햇는지 의미하는 항목 

-  스토리지 엔진 (100만개) --> MySQL엔진(필터 적용)  --> 사용자 (10건)
```
select *
from 사원
where 사원번호 between 1 and 10
```

### extra:  SQL문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목이다. 
- Distinct
    - 중복이 제거되어 유일한 값을 찾을 때 출력되는 정보
    - distinct 키워드나 union 구문이 포함된 경우 출력된다.

- Using where
    - Where 절의 필터 조건을 사용해 Mysql 엔진으로 가져온 데이터를 추출할 것이라는 의미로 사용

- Using temporary
    - 데이터의 중간 결과를 저장하고자 임시 테이블을 생성하겠다는 의미
    - 데이터를 가져와 저장한 뒤, 정렬 작업을 수행하거나 중복을 제거하는 작업등을 수행
    - DISTINCT, GROUP BY, ORDER BY 구문이 포함된 경우 사용
    - 메모리 영역을 초과하여 디스크에 임시테이블을 생성하면 성능 저하의 원인이 될 수 있다. 

- Using index
    - 물리적인 데이터 파일을 읽지 않고 인덱스만을 읽어서 SQL문의 요청사항을 처리할 수 있는 경우를 의미한다. 
    - 커버링 인덱스 방식이라고 부른다. 
        - 기본 키만 활용해서 원하는 정보를 모두 가져올 수 있는 커버링 인덱스 방식
    
- Using filesort
    - 정렬이 필요한 데이터를 메모리에 올리고 정렬 작업을 수행한다는 의미
    - <b>인덱스를 사용하지 못할 때</b> 정렬을 위해 메모리 영역에 데이터를 올린다. 
        -   추가적인 정렬 작업이므로 인덱스를 활용하도록 튜닝 할 수 있다. 
    
- Using join buffer
    - 조인을 수행하기 위해 중간 데이터 결과를 저장하는 조인 버퍼를 사용한다는 의미

- Using union/ Using intersect / Using sort_union
    - 인덱스가 병합되어 실행되는 SQL문의 extra 항목에는 인덱스를 어떻게 병합했는지에 관한 상세 정보가 출력된다. 

    - Using union: 인덱스들을 합집합처럼 모두 결합하여 데이터에 접근 (SQL구문 OR구문을 사용)
    - Using intersect: 인덱스들을 교집합처럼 추출하는 방식(SQL문이 AND구문 사용 )
    - Using sort_union: Using union과 유사하지만 Where 절의 OR 구문이 동등조건이 아닐 떄 확인할 수 있는 정보

- Using index condition
    - 필터 조건을 스토리지 엔진으로 전달하여 필터링 작업에 대한 Mysql엔진의 부하를 줄이는 방식

- Using index condition(BKA)
    - 위와 비슷하나 데이터를 검색하기 위해 배치 키 엑세스를 사용하는 방식

- Using index for group-by
    - SQL 문에 Group by구문이나 Distinct 구문이 포함될 때는 인덱스로 정렬 작업을 수행하여 최적화 한다. 
    - 인덱스로 정렬 작업을 수행하는 인덱스 루스 스캔일 때 출력되는 정보인다. 

- Not exist
    - 하나의 일치하는 행을 찾으면 추가로 행을 더 검색하지 않아도 될 때 출력되는 유형
    - 왼쪽 외부 조인 또는 오른쪽 외부 조인에서 테이블에 존재하지 않는 데이터를 명시적으로 검색할 때 발생

### 좋고 나쁨을 판단하는 기준

- select type
    - 좋음
        - SIMPLE. PRIMARY, DERIVED
    - 나쁨
        - DEPENDET
        - UNCACHEABLE

- type 
    - 좋음
        - System
        - const
        - eq_ref
    - 나쁨
        - index
        - all

- extra
    - 좋음
        - Using index
    - 나쁨
        - Using filsort
        - Using temporary


---
## 4장 악성 SQL

### 1.index를 사용하지 못하게 하는 경우
- 기본키를 변형시키는 경우
    - idx값이 11000부터 시작하는 테이블이 존재한다.해당 테이블에서 11000 ~ 11009 까지의 idx값을 가지고 있는 데이터만 조회를 할려고 한다.  이 때 기본키를 변형할 경우 성능에 이슈가 생긴다. 
    ```SQL
    <!--  안좋은 SQL의 예 기본키 변형-->
    SELECT * 
    FROM 사원
    WHERE LENGTH(사원번호) = 5 and SUBSTRING(사원번호,1,4) = 1100
    ```

- 불필요한 IFNULL 사용
    - 사원의 성별 비율을 조회하기 위해 집계 함수를 사용한다. 이 때 성별이 없을 경우 IFNULL(성별, '데이터 존재 x') 라는 필드를 사용할 경우 성능에 이슈가 생긴다. (성별은 NOT NULL인경우)
    -  NOT NULL 타입의 필드에서 NULL관련 함수 사용 x
    ```SQL
    <!-- 성능에 이슈를 생기게하는 쿼리 -->
    SELECT IFNULL(성별,'데이터없음') as 성별, count(1)
    FROM 사원
    GROUP BY 성별

    <!-- to be -->
    SELECT 성별, count(1)
    FROM 사원
    GROUP BY 성별
    ```

- 형변환으로 인덱스를 활용하지 못하는 SQL문
    - 인덱스를 활용하지 못하고 묵시적으로 형변환을 시켜 모든 데이터를 조회한다. 
        -  사용여부 인덱스를 제대로 활용하지 못하고 전체 데이터 스캔(인덱스 풀스캔)을 하여 테이블 구조를 다시 
        살펴봐야 한다. 
        
    - 데이터 유형에 맞게 열을 활용해야 내부적인 형변환이 발생하지 않는다. 
    ```SQL
    # row 2838398
    explain select count(1) from 급여 where 사용여부 = 1;

    # row 85682
    explain select count(1) from 급여 where 사용여부 = '1'
    ```


- 열을 결합하여 사용하는 나쁜 SQL문
    - 성별+' ' + 성 의 값이 'M Radwan' 인 값을 찾기 
    - CONCAT을 이용하여 열을 결합하여 조회할 경우 Explain을 Type을 알아보면 `ALL`이 나온다 
        - 악성 SQL을의미
    - `성별`,`성`을 이용하는 인덱스가 존재할 때, 해당 열의 조건만 입력하여 최적화 시킬 수 있다. 
        - 동등 조건을 사용하여 성능 향상
        - 인덱스를 활용할 수 있다. 
    ```SQL
    <!-- 악성 SQL -->
    SELECT *
    FROM 사원
    WHERE CONCAT(성별,' ',성) = 'M Radwan'

    <!-- 성능 향상 SQL (0.25  에서 0.01로 성능 향상) -->
    SELECT * 
    FROM 사원
    WHERE 성별 = 'M'
    AND 성 = 'Radwan';
    ```

- 습관적으로 중복을 제거하는 경우
    - 부서 관리자의 사원번호와 이름, 성, 부서번호 데이터를 중복 제거하여 조회하는 쿼리일 때 중복을 제거하기 위해 DISTINCT를 사용을 하지만 사원번호가 사원테이블의 PK일 경우 해당 쿼리는 악성 쿼리이다. 

    - DISTINCT 키워드는 나열된 열들을 정렬한 뒤 중복된 데이터는 삭제한다. 
        - 쿼리에 작성하는 것만으로도 정렬 작업이 포함된다. 인덱ㅅ를 활용하는 경우라면 정렬 작업은 안한다. 
    ```SQL
    <!-- 악성쿼리 -->
    SELECT DISTINCT 사원.사원번호, 이름, 성, 부서번호
    FROM 사원
    JOIN 부서관리자
    ON(사원.사원번호 = 부서관리자.사원번호); 

    <!-- 성능 향상 임시 테이블 생성 과정 생략-->
    SELECT 사원.사원번호, 이름, 성, 부서번호
    FROM 사원
    JOIN 부서관리자
    ON(사원.사원번호 = 부서관리자.사원번호); 
    ```
- 다수 쿼리를 UNION 연산자로만 합치는 나쁜 SQL문
    - UNION ALL은 여러 개의 SELECT문을 실행하는 결과를 단순히 합치는 것에 그치지만, UNION은 여러 개의 
    SELECT문 실행 결과를 합친 뒤 중복된 데이터를 제거하는 작업까지 포함한다.
    
    ```SQL
    <!-- 악성 쿼리 임시테이블 생성 -->

    SELECT 'M' AS 성별, 사원번호
    FROM 사원
    WHERE 성별 ='M' AND 성 = 'Baba'

    UNION 
    SELECT 'F', 사원번호
    FROM 사원
    WHERE 성별 = 'F'
    AND 성 = 'Baba'

    <!-- 성능 향상 쿼리 -->
    SELECT 'M' AS 성별, 사원번호
    FROM 사원
    WHERE 성별 ='M' AND 성 = 'Baba'

    UNION 
    SELECT 'F', 사원번호
    FROM 사원
    WHERE 성별 = 'F'
    AND 성 = 'Baba'
    ```

- 인덱스 고려 없이 열을 사용하는 경우
    - 인덱스1(성별, 성) 을 갖고 있는 테이블에서 성별 과 성을 그룹화하여 데이터 갯수를 집계할 경우 나오는 
    악성 쿼리
        - 그룹화 조건을 (성, 성별)로 지정하면 조회 자체는 커버링 인덱스(성별, 성)으로 조회하지만 임시테이블을 생성하여
        (성, 성별) 순으로 재정렬한다.
    ```sql
    <!-- 악성 쿼리 -->
    SELECT 성별, 성 , count(1) as 갯수
    FROM 사원
    GROUP BY 성, 성별

    <!-- 정상 쿼리 -->
    SELECT 성별, 성 , count(1) as 갯수
    FROM 사원
    GROUP BY 성별, 성
    ```

- 엉뚱한 인덱스를 사용하는 나쁜 SQL문
    - 사원 테이블에서 입사일자 열의 값이 1989이고 사원번호가 100000를 초과하는 데이터를 조회할 때 생기는 이유

    ```sql
    <!-- 악성쿼리 -->
    SELECT 사원번호
    FROM 사원
    WHERE 입사일자 LIKE '1989%'
    AND 사원번호 > 100000;

    # 실행계획 참고 -> 인덱스 참고 -> 인덱스를 활용하여 나오는 데이터 갯수 참고  -> 인덱스 활용방안 검토
    # 예시) 입사일자 기준 데이터가 제일 적으므로 입사일자 관련 인덱스를 사용하는것을 검토
    # Like 보단  부등호 관련 조건절이 우선하여 인덱스를 사용하므로 데이터 접근범위를 줄일 수 있다. 
    # LIKE 를 사용하는 경우 인덱스를 사용할 수 없어 성능상의 이슈가 생긴다. LIKE 문자열 간의 패턴 매칭을 위한 연산이다.

    SELECT 사원번호
    FROM 사원
    WHERE 입사일자 >= '1989-01-01' and  입사일자 < '1990-01-01'
    AND 사원번호 > 100000;
    ```

- 동등 조건으로 인덱스를 사용하는 경우
    - 전체데이터에서 50%이상 조회를 하게 된다면 인덱스를 사용하는 경우와 사용하지 않는 경우를 성능 분석을 하여
    체크를 해야 한다. 

    ```SQL
    <!-- 인덱스를 사용하는 경우 3.87초 걸림 -->
    SELECT *
    FROM 사원출입기록 
    WHERE 출입문 = 'B'

    <!-- 인덱스를 사용하지 않는 경우 0.85초 걸림 -->
    SELECT *
    FROM 사원출입기록 IGNORE INDEX(I_출입문)
    WHERE 출입문 = 'B'

    # 30만 기준 3배 이상 차아남
    ```



- 범위 조건으로 인덱스를 사용하는 나쁜 SQL문
    -  입사일자가 1994년 1월 1일 에서 2000년 1월 1일인 사람을 조회할 때 인덱스 스캔이 효율적인지
    테이블 풀 스캔이 효율적인지 성능 분석을 직접 해봐야 한다. 
    - 인덱스 스캔으로 랜덤 엑세스의 부하가 발생하도록 하기보다는 테이블 풀 스캔 방식을 고정적으로
    설정하는게 나을 수 있다. 

    ```SQL
    <!-- 인덱스 스캔 활용 -->
    SELECT 이름, 성
    FROM 사원
    WHERE 입사일자 >= '1994-01-01' and 입사일자 <='2000-12-31';

    <!-- 풀스캔 유도 -->
    SELECT 이름,성
    FROM 사원
    WHERE YEAR(입사일자) BETWEEN '1994' and  '2000'
    ```


- 메인 테이블에 계속 의존하는 나쁜 SQL문
    - 해당 쿼리
    ```SQL
    SELECT 사원.사원번호, 사원.이름, 사원.성
      FROM 사원
    WHERE 사원번호 > 45000
    AND (SELECT MAX(연봉) FROM 급여 WHERE 사원번호 = 사원.사원번호) > 100000;

    -- 해당 쿼리의 실행계획에서는 중첩 쿼리에서 `select type` 이 DEPENDENT SUBQUERY 가 일어난다.
    -- 실행계획에서 해당 타입이 나오면 튜닝을 할 생각을 해야한다. 왠만하면 조인을 이용한 것이 더빠르다.
    ```

    - 튜닝 쿼리
    ```SQL 
    SELECT 사원.사원번호, 사원.이름, 사원.성
      FROM 사원
      INNER JOIN 급여
              ON 급여.사원번호 = 사원.사원번호
    WHERE 사원.사원번호 > 45000
    GROUP BY 사원.사원번호
    having MAX(급여.연봉) > 100000;
    ```


- 불필요한 조인을 수행하는 나쁜 SQL문
    - 존재유무만 확인하기 위해 조인을 거는것보단 Exists를 이용하여 존재유무만 판단하는 쿼리가 훨씬빠르다.
    ```SQL
    // 해당 쿼리를 실행하면 기록 테이블이 드라이빙테이블이 되어 사원번호 데이터를 다 가져온 뒤, 
    // 사원 테이블과 비교를 하게 된다.
    EXPLAIN
    SELECT COUNT(DISTINCT 사원.사원번호) as 데이터건수
    FROM 사원,
        (SELECT 사원번호
        FROM 사원출입기록 기록
        WHERE 출입문 = 'A') AS 기록
    WHERE 사원.사원번호 = 기록.사원번호;

    DESC 사원;

    // 해당 쿼리는 사원테이블이 드라이빙테이블입니다. 
    // 사원테이블에서 사원번호를 가져와서 출입기록에 데이터유무만 판단하여 데이터를 뿌려준다. 
    // 근데 왜 더 빠른거지? exists를 이용해서 데이터유무만 판단하기 때문인가?
    EXPLAIN
    SELECT count(1)
    FROM 사원
    WHERE exists(SELECT 1 FROM 사원출입기록 기록 WHERE 기록.출입문 = 'A' AND 기록.사원번호 = 사원.사원번호)
    ```
