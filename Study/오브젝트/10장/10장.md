# 상속과 코드 재사용

코드 재사용
- 객체 지향에서는 클래스를 재사용하는 전통적인 방법은 새로운 클래스를 추가하는 것이다.

## 상속과 중복 코드


### DRY 원칙

- 중복 코드는 변경을 방해한다. 
    - 이유가 무엇이건 일다 새로운 코드를 추가하고 나면 언젠가는 변경될 것이라고 생각하는 것이 현명하다. 

- 중복 여부 판단
    - 두 코드를 함께 수정해야 한다면 그 코드는 중복이다.
    - 중복 여부를 결정하는 기준은 코드가 변경에 반응하는 방식이다. 

- 신뢰할 수 있고 수정하기 쉬운 소프트웨어를 만드는방법
    - 중복을 제거(DRY 원칙 - Don't Repeat Yourself)
        - DRY 원칙 
            - 모든 지식은 시스템 내에서 단일하고 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. 


### 중복과 변경

- 중복 코드 수정하기
    - 중복 코드는 항상 함께 수정돼야 하기 때문에 수정할 때 하나라도 빠트린다면 버그로 이어진다. 
    - 중복 코드를 서로 다르게 수정하기 쉽다.
    - 중복 코드가 늘어날 수록 애플리케이션은 변경에 취약하고 버그가 발생할 가능성이 높아진다.

<br/>

### 타입코드 사용하기
두 클래스 사이의 중복 코드를 제거하는 한가지 방법은 클래스를 하나로 합치는 것이다. <br/>

타입 코드를 사용하는 클래스는 낮은 응집도와 높은 결합도라는 문제에 시달리게 된다.

```java

public class Phone {
    enum phoneType {REGULAR,NIGHTLY}

    private PhoneType type;
}

```


### 상속을 이용해서 중복 코드 제거하기
- 상속을 위한 경고 
```

1. 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두  클래스는 강하게 결합된다. super 호출을 제거할 수 있는 
방법을 찾아 결합도를 제거하라. 

2. 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨뜨릴 수 있다. 

3. 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다. 

4. 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다. 
```

- 이미 존재하는 클래스와 유사한 클래스가 필요하다면 코드를 복사하지 말고 상속을 이용해 코드를 재사용하라는 의미


- 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 쉽지 않다.
    - 개발자의 생각을 읽고 이해하는데 시간이 오래걸린다.
    - 요구사항과 구현 사이의 차이가 크면 클수록 코드를 이해하기 어려워진다. 
    - 잘못 사용된 상속을 이 차이를 더 크게 벌린다. 
    - 코드 중복을 제거하기 위해 상속을 사용했음에도 중복 코드를 만들경우가 생긴다. 
    - 강한 결합도를 유발한다. 



## 취약한 기반 클래스 문제

Fragile Base Class Problem, Brittle Base Class Problem

상속 관계로 연결된 자식 클래스가 부모 클래스의 변경에 취약해지는 현상을 가리켜 취약한 기반 클래스 문제라고 부른다. <br/>

- 상속이라는 문맥 안에서 결합도가 초래하는 문제점을 가리키는 용어
    - 최악의 경우에는 모든 자식 클래스를 동시에 수정하고 테스트해야 할 수 있다.

- 취약한 기반 클래스는 캡슐화를 약화시키고 결합도를 높인다. 
    - 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다. 

- 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화 할 수 있기 때문이다. 
    - 캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다. 


### 상속의 문제점

-  불필요한 인터페이스 상속 문제
    - Vector - Stack
        - Stack은 Vetor를 상속하지만 불필요한 메소드까지 상속을 받는다(Stack에서 사용하면 안되는 메소드까지 상속받음)
        
        - 규칙을 무너뜨릴수도 있다. 
    - 불필요한 오퍼레이션이 인터페이스에 스며들도록 방치해서는 안된다.
    
     <br/>

- 메서드 오버라이딩의 오작용 문제
    - 미래에 발생할지 모르는 위험을 방지하기 위해 코드를 중복 시키는 경우를 초래한다. 
        - 부모 클래스에 있는 메소드에서 약간의 수정이 필요할 경우 중복코드를 유발할 수 있기 때문이다. 

    - 메서드 오버라이딩으로 인한 파급 효과를 분명하게 문서화해야한다. 
        - 메서드들이 같은 클래스의 다른 메서드를 호출하는지에 대해 반드시 문서화해야한다. 

    - 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야한다.

- 부모와 자식의 동시 수정 문제
    - 부모 클래스가 변경되면 자식 클래스도 관련된 사항에대해서는 동시에 수정을 해줘야 한다.
        - 부모클래스에서 기존 요구사항이 변경됐다면 자식 클래스도 그와 관련된 모든 사항을 수정을 해줘야되기 때문이다. 


## 올바른 상속

### 추상화에 의존하자.

- 자식 클래스가 부모 클래스의 구현이 아닌 추상화에 의존하도록 만든다. 
    - 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.

    - 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.
        - 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다. 

        
- 차이를 메서드로 추출하라
    - 중복 코드 안에서 차이점을 별도의 메서드로 추출하는 것이다. 
        - 변하는 것으로부터 변하지 않는 것을 부리하라.
        - 변하는 부분을 찾고 이를 캡슐화하라.


- 중복 코드를 부모 클래스로 올려라
    - 목표는 모든 클래스들이 추상화에 의존하도록 만드는것이기 때문에 이 클래스는 추상클래스로 구현하는 것이 적합하다. 


- 구체적인 구현을 아래로 내리는 방식으로 현재 클래스를 구체 클래스에서 추상 클래스로 변경하려 한다면 작은 실수 한 번으로도 구체적인 행동을 상위 클래스에 남겨 놓게 된다. 


## 추상화가 핵심이다.

- 추상화를 사용하여 상속하면 각 클래스는 서로 다른 변경의 이유를 가진다.
- 부모 클래스 역시 자신의 내부에 구현된 추상 메서드를 호출하기 때문에 추상화에 의존한다고 말할 수 있다. 

- 상속 계층이 코드를 진화시키는데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링하라. 


## 차이에 의한 프로그래밍

- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법을 `차이에 의한 프로그래밍` 이라고 한다. 

- 중복을 제거하기 위해서는 코드를 재사용 가능한 단위로 분해하고 재구성해야 한다. 

- 재사용 가능한 코드란 심각한 버그가 존재하지 않는 코드다. 


`상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다. 정말로 필요한 경우에만 상속을 사용하라`