# 강의내용 정리


## 좋은 구현

### 비즈니스 가치를 명확히 충족 시켜야 한다.

- 기술은 도구일 뿐이다.
- 도구에 익숙해지고 좀 더 좋은 도구를 찾는 근원적인 이유도 비즈니스 목표 달성을 위한 것이다.


### 잘 읽혀야 한다.

- 개발 업무를 단순히 코드의 읽기와 쓰기로 분류하면 8[읽기]:2[쓰기] 정도의 비중이 된다.
    - 코드 자체의 가독성이 좋아야 업무 효율을 지속적으로 높게 유지할 수 있다.

### 테스트 코드 작성이 쉬워야 한다.

- 테스트 코드는 지속적인 기능 런칭과 리팩토링을 가능하게 해주는 안전장치이다.

- 코드간의 의존성이 많다면 그만큼 테스트 코드 작성이 어렵다.
- 테스트 코드 작성이 쉬운 코드는 대체적으로 코드 품질이 좋은 편이다.


### 변경에 유연해야 한다.
- 요구사항은 언제든지 추가되고 바뀔 수 있다.
- 코드 구현과 설계는 요구사항 변경에 유연하도록 작성되어야 한다.

```bash
단일 책임 원칙
개방 폐쇄 원칙
리스코프 치환 원칙
의존 관계 역전 원칙
인터페이스 분리 원칙

# 객체지향 설계 원칙
```

## 도메인 주도 설계

- 마이크로 서비스 아키텍처의 컨셉을 생각하면 비즈니스 도메인 중심으로 서비스를 모델링하고 구현하는 것이 중요하다.

- 각각의 복잡한 도메인을 모델링하고 표현력있게 설계하는 것을 도메인 주도 설계라고 한다.


- Layer 별 특징과 역할

```bash
# 레이어간의 참조 관계에서는 단방향 의존을 유지하고 계층간 호출에서는 인터페이스를 통한 호출이 되도록 한다.


#사용자 인터페이스
>> 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다.
>> ex) "Controller, Dto,Mapper(Converter)"

#응용계층
>> 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용 계층과 상호 작용하는 데 필요한 것들이다.
이 계층은 얇게 유지되고 , 오직 작업을 조정하고 아래에 위치한 계층에 포함된 도메인 객체의 협력자에게 작업을 위임한다.

>> ex) "Facade"

# 도메인 계층(domain)
>> 업무 개념과 업무 상황에 대한 정보, 업무 규칙을 표현하는 일을 책임진다. 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라 스트럭쳐에 위임한다. 이 계층이 업무용 소프트웨어의 핵심이다.

>> ex)"Entity,Service,Commain,Criteria,Info,Reader,Stroe,Executor,Factory(interface)"

#인프라 스트럭쳐 계층(infrastructure)
>> 상위 계층을 지원하는 일반화된 기술적 기능을 제공한다.
이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI에 위젯을 그리는 것 등이 있다.

>> ex)"low level 구현체,(readerImpl,StoreImpl,Spring JPa,RedisConnector..."
```


- Facade패턴이란?
     - Facade Pattern의 목적은 복잡한 서브시스템을 인터페이스로 감싸 간단하게 만드는 것이다.

- 강의 내에서 domain layer 표준 구현

```bash
# 1 
1. domain layer에서의 Service 에서는 해당 도메인의 전체 흐름을 파악할 수 있도록 구현되어야 한다.

>> 이를 위해서는 추상화 레벨을 많이 높여야 한다.
    >> 도메인 로직에서는 어떤 기술을 사용했는지는 중요하지 않다. 어떤 업무를 어떤 순서로 처리했는지가 더욱 중요한 관심사이다.

    >> 도메인 업무는 적절한 interface를 사용하여 추상화하고 실제 구현은 다른 layer에 맡기는게 맞다.

>> 세세한 기술 구현은 Service가 아니라 infrastructure의 implements클래스에 위임하고, Service에서는 이를 활용하기 위한 interface를 선언하고 사용한다.
    
    >> DIP를 활용하여 도메인이 사용하는 interface의 실제 구현체를 주입받아사용할 수 있도록 한다.

    >> 영속화된 객체를 로딩하기 위해 Spring JPA를 사용할 수도 있지만 Mybatis를 사용할 수도 있는 것이다. domain layer에서는 객체를 로딩하기 위한 추상화된 interface를 사용하고, 실제 동작은 하위 layer의 기술 구현체에 맡긴다는 것이 핵심이다. 

#2
2. domain layer에서의 모든 클래스명이 XxxService로 선언될 필요는 없다.

>> 하나의 도메인 패키지 내에 수많은 Service클래스가 존재하게 되면, 도메인 전체의 흐름을 컨트롤하는 Service가 무엇인지 알기 어렵다.
    >> 주요 도메인의 흐름을 관리하는 Service는 하나로 유지하고, 이를 위한 support역할을 하는 클래스는 Service이외의 네이밍을 가져가는 것이 좋다. 

    >> 또한 하나의 책임을 가져가는 각각의 구현체는 그 책임과 역할에 맞는 네이밍으로 선언하는 것이 가독성에 좋다.

        >> ex) XxxxReader, XxxxStore, XxxxExecutor

    >> 다만 해당 구현체는 domain layer에서는 interface로 추상화하고 실제 구현체는 infrastructure layer에서 구현한다.

    >> 즉 domain layer에서는 도메인 로직의 흐름을 표현하고 구현하는 Service와 ServiceImpl이 있지만 그 외의 상세한 구현은 Reader,Store,Executor같은 interface를 선언하여 사용하고 이에 대하 ㄴ실제 구현체는 infrastructure layer에 두고 활용한다 (DIP)


#3 
3. Service간에는 참조 관계를 가지지 않도록 한다.

# Aggregate Root : 연관 객체의 묶음

>> Entity 관에도 상하 관계가 명확히 생긴다

>> Service로직을 구현하다보면 좀 더 상위 레벨의 Service와 하위 레벨의 Service가 도출되기 마련인데, 이런 구조를 허용하게 되면 상위 레벨의 Service가 하위 레벨의 Service를 다수 참조하게 되면서 로직이 구성된다.

    >> 경험상 시간이 지날수록 특정 Service가 참조하는 하위 Service는 점점 늘어나는 경향이 있다.
    >> 이는 테스트 코드 작성을 어렵게 하고 가독성도 많이 떨어지게 된다.

>> Service간에는 참조 관계를 가지지 않도록 원칙을 세우는 것이 좋다.

    >> Service내의 로직은 추상화 수준을 높게 가져가고
    >> 각 추상화의 실제 구현체는 잘게 쪼개어 만들면
    >> 도메인의 전체 흐름이 파악되면서도 로직이 간결하게 유지되는 코드를 가져갈 수 있다. 
    

```