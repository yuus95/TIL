# 단위테스트

## 단위테스트를 하는 이유 
- 어떤 기능을 막 코딩했고 그것이 예상한 대로 작동하는지 알고싶습니다.

- 시스템에 작성한 변경 사항을 문서화하여 자신과 다른 사람들이 나중에 이해하도록 하고 싶습니다.

- 코드를 변경하고 그것으로 변경된 사항이 기존 동작을 깨뜨리지 않았는지 
확인하고 싶습니다.

- 시스템의 현재 동작을 이해하고 싶다.

- 서드 파티 코드가 더 이상 기대한 대로 동작하지 않을 떄 를 알고자 합니다.


## 동작 테스트 VS 메서드  테스트

-   테스트를 작성할 떄는 클래스 동작에 집중해야 하며 개별 메서드를
테스트한다고 생각하면 안됩니다.

- EX) 은행 ATM 

```
deposit() - 입금
withdraw() - 인출
getBalance() - 잔액확인

- makeSingleDeposit (x) :deposit 메소드는 단지 객체의 필드만 리턴하므로 의미가 없다.

-> 
1.테스트 대상이 될만한 흥미로운 동작에는 입금과 출금 같은 다른 동작이 
먼저 나와야 한다. 

2. 단위 테스트를 작성할 때는 먼저 전체적인 시각에서 시작해야 한다. 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작을 테스트해야한다.
- makeSingWithDrawal :  
- makeMultipleWithdrawls : 

```


## AAA테스트

- 준비(Arange) 
    - 테스트 코드를 실행하기전에 시스템이 적절한 상태에 있는지 확인
    - 객체들을 생성하거나 이것과 의사소통 하거나 다른 API를 호출하는 것등의 역할을 한다.
    - 드물지만 시스템이 우리가 필요한 상태로 있다면 준비 상태를 생략

- 실행(Act)
    - 테스트 코드를 실행합니다. 보통은 단일 메서드를 호출

- 단언(Assert)
    - 실행한 코드가 기대한 대로 동작하느지 확인
    - 실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사합니다.
    


## 일관성 있는 이름으로 테스트 문서화

- 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시해야한다
- 주요 목표는 테스트코드를 다른사람에게 의미 있게 만드는 것입니다.

ex)
```
makeSingleWithdrawal
    -> withdrwalReducesBalanceByWithdrawnAmount

attemptToWithdrawTooMuch
    -> withdrawlaofMoreThanAvailableFundsGeneratesError

multipleDeposits
    -> multipleDepositsIncreaseBalanceBySumOfDeposits
```

- 양식 
    - doingSomeOperationGeneratesSomeResult(어떤 동작을 하면 어떤 결과가 나온다)

    - someResultOccursUnderSomeCondition(어떤 결과는 어떤 조건에서 발생한다.)


## 좋은 테스트의 Fisrt속성
    - TDD:  테스트를 먼저 작성하고 코드를 작성하면 이전과 다른 더 좋은 결과를 얻을 수 있다.

- Fast : 빠른
    - 테스트 종류
        - 빠른 테스트 : 코드만 실행하는 테스트
        - 느린 테스트 : 데이터베이스, 파일, 네트워크 호출 처럼 필요한 외부자원을 다루는 코드를 호출.
    - 테스트 코드는 빠르게 동작하며 , 느린 것에 의존하는 코드를 최소화한다면 작성하기도 쉬워진다.

    - 코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워진다.
    - 단위 테스트는 빠르게 수행되어 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주는 데 그 가치가 있기 떄문에 이를 달성하지 못한다면 테스트를 작성하는 것 자체가 무의미해질 수 있다.

    
    
- Isolated: 고립된
    - 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않습니다.
    - 테스트코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 한다.
        - 각 테스트가 작은 양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로 유지하기 쉬워진다.
    - 테스트 대상 코드는 데이터베이스를 읽는 다른 코드와 상호 작용할 수 있다.
        - 단순히 외부 저장소와 상호작용하게되면 테스트가 가용성 혹은 접근성 이슈로 실패할 가능이 증가한다.
    - SRP : 클래스를 변경해야 할 이유가 하나만 있어야 한다.
        - 테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해봐야 한다.
    
- Repeatable: 반복가능한
     - 테스트 설계에서 우리의 역할 중 일부는 테스트 결과가 매번 어떻게 나와야 하는지에 대해 설명하는 단언을 제공하는 것입니다.
     - 반복 가능한 테스트는 실행할 때마다 결과가 같아야 합니다. 
     - 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리 시켜야 합니다.

- Self-validating: 스스로 검증가능하다  
    - 테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아닙니다.
    - 테스트는 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 합니다.

- Timely: 적시의
    - 단위 테스트 코드를 검증하는 것을 미룰수록 피해는 커진다.
    
    - 단위 테스트를 더 많이 할수록 테스트 대상 코드가 줄어든다. 
    - 단위 테스트를 작성할 수록 단위 테스트 작성이 쉬워진다   
    - 새로운 코드를 넣었을 떄 테스트 효과가 즉시 나타난다.
    - 옛날 코드에 대한 테스트는 시간 낭비가 될 수 있다.
        - 코드에  큰 결함이 없고 당장 변경할 예정이 없다면 노력의 보상을 못받을 수 있다.


## Right-BICEP 무엇을 테스트 할 것인가?



```
Right: 결과가 올바른가? 
B: 경계 조건(boundary conditions)은 맞는가?
I: 역 관계(inverse relationship)를 검사할 수 있는가?
C: 다른 수단을 활용하여 교차 검사(cross-check)할 수 있는가?
E: 오류 조건(error conditions)을 강제로 일어나게 할 수 있는가?
P: 성능 조건(performance characteristics)은 기준에 부합하는가?
```

- Right
    - 테스트 코드는 무엇보다도 먼저 기대한 결과를 산출하는지 검증할 수 있어야 합니다.

    - 어떤 작은 부분의 코드에 대해 행복 경로 테스트를 할 수 없다면 그 내용을 완전히 이해하지 못한 것입니다. 앞의 질문에 대답할 수 있을 때까지 잠시  추가 개발은 보류하면 좋습니다.    
       - 행복 경로 테스트 :  나는 코드가 정상적으로 동작한다면, 그것을 알 수 있을까?


- B(경계조건은 맞는가?)
    - 클래스를 설계할 떄 잠재적인 정수 오버플로 등을 고려할지 여부는 .전적으로 우리에게 달려있습니다. 클래스가 외부에서 호출하는 API이고 클라이언트를 완전히 믿을 수 없다면 나쁜 데이터에 대한 보호가 필요합니다.

    - 클라이언트가 우리팀 소속이라면 앞서 살펴본 보호절들을 제거하고 클라이언트에게 알려줘도 된다.

    - 더 좋은 것은 코드 제한 사항을 문서화하는 테스트를 추가합니다.
    
    - 경계 조건에서는 CORRECT를 기억하라
        - Conformance(준수) : 값이 기대한 양식을 준수하고 있는가?
        - Ordering(순서) 값의 집합이 적절하게 정렬되거나 정렬되지 않았나?
        - Range(범위) : 이성적인 최솟값과 최댓값 안에 있는가?
        - Reference(참조): 코드 자체에서 통제할 수 없는 어떤 외부 참조를 포함하고 있는가?
        - Existence(존재): 값이 존재하는가(널이 아니거나(non-null), 0이 아니거나(non-zero), 집합에 존재하는가 등)

        - Cardinality(기수): 정확히 충분한 값들이 있는가?
        - Time(절대적 혹은 상대적 시간) : 모든 것이 순서대로 일어나는가? 정확한 시간에? 정시에?


- I(역관계를 검사할 수 있는가?)
    - 때때로 논리적인 역 관계를 적용하여 행동을 검사할 수 있습니다. 종종 수학 계산에서 사용합니다. 곱셈으로 나눗셈을 검증하고 뺄셈으로 덧셈을 검증하는 것 처럼 사용한다.


- C(다른 수단을 활용하여 교차 검사할 수 있는가)
    - 흥미로운 문제에는 무수한 해법이 존재합니다.대부분  그중 성능이 좋은 해범을 선택합니다. 아마도 프로덕션 시스템에 활용하기에는 너무 느리거나 유연하지 않겠지만, 그것들이 믿을 수 있고 참값을 보장한다면 교차 검사할 때 활용할 수 있습니다.

- E(오류 조건을 강제로 일어나게 할 수 있는가?)
    - 행복경로가 있다는 것은 반대로 불행한 경로도 있다는 것을 의미합니다.
    - 테스트 코드로 모든 실전 문제를 우아하고 이성적인 방식으로 다루기 원할 것이다.
        - 그렇게 하려면 테스트도 오류들을 강제로 발생 시켜야 합니다.

    - 좋은 단위 테스트는 단지 코드에 존재하는 로직 전체에 대한 커버리지를 달성하는 것이 아닙니다. 때때로 뒷주머니에서 작은 창의력을 꺼내는 노력이 필요합니다. 가장 끔찍한 결합들은 종종 전혀 예상하지 못한 곳에서 나옵니다.

- P(성능 조건은 기준에 부합하는가?)
    - 성능 테스트 주의 사항
        - 전형적으로 코드 덩어리를 충분한 횟수만큼 실행해야 결과 수치가 튀지 않습니다.
        - 반복하는 코드 부분을 자바가 최적화하지 못하는지 확인해야 합니다.
        - 최적화되지 않은 테스트는 한 번에 수 밀리초가 걸리는 일반적인 테스트 코드들보다 매우 느립니다.
        느린 테스트들은 빠른 것과 분리해야 한다.

    - 단위 성능 측정을 잘 사용하는 방법은 변경 사항을 만들 때 기준점으로 활용하는 것이다.

    - 최적화를 하기 전에 먼저 기준점으로 단지 현재 경과 시간을 측정하는 성능 테스트를 작성해야한다.

    - 성능이 핵심 고려 사항이라면 단위 테스트보다는 좀 더 고수준에서 문제에 집중하고 싶을 것이고, JMeter같은 도구를 사용하길 원할 수도 있습니다.




## Custom Exception Handling 

- https://www.baeldung.com/exception-handling-for-rest-with-spring 공부내용정리

-  Spring5는 RestAPI 에서 기본 오류 처리를 위한 빠른 방법인 Response Status Exception 클래스를 도입했다.



### Solution 1 - the Controller - level 

- 첫번 째. @Controller단에서 작업한다.

```java
public class yushinController{
    
    //api작성
    
    @ExceptionHandler({CustomException.class,CustomException2.class})
    public void handleException(){
        //내용
    }
}

```

- 단점
    - @ExceptionHandler에 표시된 메소드들은 오직 특정 컨트롤러에만 반응한다


### ResponseStatusException(Spring5이상)


```java

@Getmapping(value ="/{id}")
public foo findById(@PathVariable("id") Long id,HttpServeletResponse response){
    try{
        Foo resourceById = RestPreconditions.checkFound(service.findOne(id));

        eventPublisher.publishEvent(new SingleResourceRestrievedEvent(this,response));

        return resourceById;
    }
    catch(MyResourceNotFoundException exc){
        throw new ResponseStatusException(HttpStatus.NOT_FOUND,"Foo Not Found",exc);
    })
}

```


