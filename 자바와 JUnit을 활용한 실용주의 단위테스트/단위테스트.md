# 단위테스트

## 단위테스트를 하는 이유 
- 어떤 기능을 막 코딩했고 그것이 예상한 대로 작동하는지 알고싶습니다.

- 시스템에 작성한 변경 사항을 문서화하여 자신과 다른 사람들이 나중에 이해하도록 하고 싶습니다.

- 코드를 변경하고 그것으로 변경된 사항이 기존 동작을 깨뜨리지 않았는지 
확인하고 싶습니다.

- 시스템의 현재 동작을 이해하고 싶다.

- 서드 파티 코드가 더 이상 기대한 대로 동작하지 않을 떄 를 알고자 합니다.


## 동작 테스트 VS 메서드  테스트

-   테스트를 작성할 떄는 클래스 동작에 집중해야 하며 개별 메서드를
테스트한다고 생각하면 안됩니다.

- EX) 은행 ATM 

```
deposit() - 입금
withdraw() - 인출
getBalance() - 잔액확인

- makeSingleDeposit (x) :deposit 메소드는 단지 객체의 필드만 리턴하므로 의미가 없다.

-> 
1.테스트 대상이 될만한 흥미로운 동작에는 입금과 출금 같은 다른 동작이 
먼저 나와야 한다. 

2. 단위 테스트를 작성할 때는 먼저 전체적인 시각에서 시작해야 한다. 개별 메서드를 테스트하는 것이 아니라 클래스의 종합적인 동작을 테스트해야한다.
- makeSingWithDrawal :  
- makeMultipleWithdrawls : 

```


## AAA테스트

- 준비(Arange) 
    - 테스트 코드를 실행하기전에 시스템이 적절한 상태에 있는지 확인
    - 객체들을 생성하거나 이것과 의사소통 하거나 다른 API를 호출하는 것등의 역할을 한다.
    - 드물지만 시스템이 우리가 필요한 상태로 있다면 준비 상태를 생략

- 실행(Act)
    - 테스트 코드를 실행합니다. 보통은 단일 메서드를 호출

- 단언(Assert)
    - 실행한 코드가 기대한 대로 동작하느지 확인
    - 실행한 코드의 반환값 혹은 그 외 필요한 객체들의 새로운 상태를 검사합니다.
    


## 일관성 있는 이름으로 테스트 문서화

- 어떤 맥락에서 일련의 행동을 호출했을 때 어떤 결과가 나오는지를 명시해야한다
- 주요 목표는 테스트코드를 다른사람에게 의미 있게 만드는 것입니다.

ex)
```
makeSingleWithdrawal
    -> withdrwalReducesBalanceByWithdrawnAmount

attemptToWithdrawTooMuch
    -> withdrawlaofMoreThanAvailableFundsGeneratesError

multipleDeposits
    -> multipleDepositsIncreaseBalanceBySumOfDeposits
```

- 양식 
    - doingSomeOperationGeneratesSomeResult(어떤 동작을 하면 어떤 결과가 나온다)

    - someResultOccursUnderSomeCondition(어떤 결과는 어떤 조건에서 발생한다.)


## 좋은 테스트의 Fisrt속성
    - TDD:  테스트를 먼저 작성하고 코드를 작성하면 이전과 다른 더 좋은 결과를 얻을 수 있다.

- Fast : 빠른
    - 테스트 종류
        - 빠른 테스트 : 코드만 실행하는 테스트
        - 느린 테스트 : 데이터베이스, 파일, 네트워크 호출 처럼 필요한 외부자원을 다루는 코드를 호출.
    - 테스트 코드는 빠르게 동작하며 , 느린 것에 의존하는 코드를 최소화한다면 작성하기도 쉬워진다.

    - 코드를 클린 객체 지향 설계 개념과 맞출수록 단위 테스트 작성도 쉬워진다.
    - 단위 테스트는 빠르게 수행되어 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주는 데 그 가치가 있기 떄문에 이를 달성하지 못한다면 테스트를 작성하는 것 자체가 무의미해질 수 있다.

    
    
- Isolated: 고립된
    - 좋은 단위 테스트는 다른 단위 테스트에 의존하지 않습니다.
    - 테스트코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 한다.
        - 각 테스트가 작은 양의 동작에만 집중하면 테스트 코드를 집중적이고 독립적으로 유지하기 쉬워진다.
    - 테스트 대상 코드는 데이터베이스를 읽는 다른 코드와 상호 작용할 수 있따.
        - 단순히 외부 저장소와 상호작용하게되면 테스트가 가용성 혹은 접근성 이슈로 실패할 가능이 증가한다.
    - SRP : 클래스를 변경해야 할 이유가 하나만 있어야 한다.
        - 테스트 메서드가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해봐야 한다.
    
- Repeatable: 반복가능한
     - 테스트 설계에서 우리의 역할 중 일부는 테스트 결과가 매번 어떻게 나와야 하는지에 대해 설명하는 단언을 제공하는 것입니다.
     - 반복 가능한 테스트는 실행할 때마다 결과가 같아야 합니다. 
     - 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리 시켜야 합니다.

- Self-validating: 스스로 검증가능하다  
    - 테스트는 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아닙니다.
    - 테스트는 스스로 검증 가능할 뿐만 아니라 준비할 수도 있어야 합니다.

- Timely: 적시의
    - 단위 테스트 코드를 검증하는 것을 미룰수록 피해는 커진다.
    
    - 단위 테스트를 더 많이 할수록 테스트 대상 코드가 줄어든다. 
    - 단위 테스트를 작성할 수록 단위 테스트 작성이 쉬워진다   
    - 새로운 코드를 넣었을 떄 테스트 효과가 즉시 나타난다.
    - 옛날 코드에 대한 테스트는 시간 낭비가 될 수 있다.
        - 코드에  큰 결함이 없고 당장 변경할 예정이 없다면 노력의 보상을 못받을 수 있다.


## Right-BICEP 무엇을 테스트 할 것인가?



```
Right: 결과가 올바른가? 
B: 경계 조건(boundary conditions)은 맞는가?
I: 역 관계(inverse relationship)를 검사할 수 있는가?
C: 다른 수단을 활용하여 교차 검사(cross-check)할 수 있는가?
E: 오류 조건(error conditions)을 강제로 이렁나게 할 수 있는가?
P: 성능 조건(performance characteristics)은 기준에 부합하는가?
```

- Right
    - 테스트 코드는 무엇보다도 먼저 기대한 결과를 산출하는지 검증할 수 있어야 합니다.

    - 어떤 작은 부분의 코드에 대해 행복 경로 테스트를 할 수 없다면 그 내용을 완전히 이해하지 못한 것입니다. 앞의 질문에 대답할 수 있을 때까지 잠시  추가 개발은 보류하면 좋습니다.    
       - 행복 경로 테스트 :  나는 코드가 정상적으로 동작한다면, 그것을 알 수 있을까?
